# CAN 서보모터 제어 보드 사용 설명서 V0.8.5

## 목차
- [서문](#서문)
- [제어 보드 설명](#제어-보드-설명)
- [전원 권장사항](#전원-권장사항)
- [배선 도식도](#배선-도식도)
- [제어 명령어](#제어-명령어)
  - [MP3 재생 명령](#mp3-재생-명령)
  - [동작 제어 명령](#동작-제어-명령)
  - [서보모터 제어 명령](#서보모터-제어-명령)
- [Arduino 프로그래밍 예제](#arduino-프로그래밍-예제)
  - [예제 1: UNO 프로그래밍](#예제-1-uno-프로그래밍)
  - [예제 2: Mega2560 프로그래밍](#예제-2-mega2560-프로그래밍)
  - [예제 3: PS2 컨트롤러](#예제-3-ps2-컨트롤러)
  - [예제 4: 라즈베리파이 프로그래밍](#예제-4-라즈베리파이-프로그래밍)
- [시교 동작 그룹](#시교-동작-그룹)
- [펌웨어 업그레이드](#펌웨어-업그레이드)

---

## 서문

타오바오에서 우연히 좋은 물건을 발견: 60K 로봇 디지털 서보모터, 구동할 수 없는 것을 발견했습니다.
네트워크를 기반으로 일부 자료를 정리했습니다.

**학습 교류용으로만 사용하며, 상업적 용도는 금지합니다!**

### 주요 특징

- **시리얼 포트 예비**: WiFi, 블루투스, 적외선, 433 등 외부 제어 지원
- **다양한 컨트롤러 지원**: 라즈베리파이, UNO, STM32, 51 등 모든 마이크로컨트롤러 시리얼 포트 제어 지원
- **제어 보드**: 여러 서보모터의 협조 작업을 관리하는 시스템으로, 명령만 주면 제어 가능하여 매우 친화적입니다

---

## 제어 보드 설명

### 전원 권장사항

**전원**: 24V 3A 파워 서플라이 또는 6S 배터리 팩(18650 배터리 6개) 사용

### 배선 도식도

![배선 도식도](./images/wiring_diagram_board.png)

---

## 제어 명령어

간단명료하게 하기 위해 여기서는 몇 가지 자주 사용하는 명령을 선택합니다:

### 명령 구조 규칙

```
// 명령은 A9 9A로 시작
// {len} = cmd[2] = count({len} xx .. xx)
// {sum} = cmd[{len} + 2] = sum({len} xx .. xx)
//
// Size = A9 9A [{len} ...] {sum} ED = [{len} ... ] + 4 = len + 4
// minimum : A9 9A 2 {cmd} {sum} ED = 6
```

---

### MP3 재생 명령

#### 1. MP3 정지 (명령 코드: 32)

```
A9 9A 02 32 34 ED
```
MP3 재생 중지

#### 2. 파일 재생 (명령 코드: 33)

```
A9 9A 04 33 01 03 3B ED
```
SD 카드의 /01/003.mp3 재생 (01 디렉토리)

```
A9 9A 04 33 01 04 3B ED
```
SD 카드의 /01/004.mp3 재생 (01 디렉토리)

#### 3. MP3 파일 재생 (명령 코드: 34)

```
A9 9A 03 34 01 38 ED
```
SD 카드의 /MP3/001.mp3 재생 (MP3 디렉토리)

```
A9 9A 03 34 FF 38 ED
```
SD 카드의 /MP3/255.mp3 재생 (MP3 디렉토리)

---

### 동작 제어 명령

#### 1. 동작 재생 (명령 코드: 41)

```
A9 9A 03 41 01 45 ED
```
동작 그룹 1 재생

```
A9 9A 03 41 03 47 ED
```
동작 그룹 3 재생

#### 2. 반복 재생 (명령 코드: 42)

```
A9 9A 04 42 01 02 49 ED
```
1번 동작 그룹, 2회 반복 재생
- cmd[5]=0xFF이면 무한 반복

#### 3. 재생 중지 (명령 코드: 4F)

```
A9 9A 02 4F 51 ED
```
동작 그룹 재생 중지

#### 4. 동작 파일 삭제 (명령 코드: 75)

```
A9 9A 03 75 06 7E ED
```
6번 동작 그룹 삭제

#### 5. 특정 동작 재생 (명령 코드: 84)

```
A9 9A 05 84 03 00 01 8D ED
```
3번 동작 그룹의 첫 번째 포즈 재생
- 바둑 로봇 팔, 물품 다위치 적재 등에 적합
- cmd[4]: 지정된 동작 그룹 ID
- cmd[6]: 동작 그룹 내 지정된 동작 ID
- cmd[9]: 체크섬 값

#### 6. 동작 헤더 읽기 (명령 코드: 61)

```
A9 9A 03 61 06 6A ED
```
6번 동작 그룹 이름 데이터 읽기

#### 7. 동작 데이터 읽기 (명령 코드: 62)

```
A9 9A 05 62 02 00 01 6A ED
```
2번 동작 그룹의 첫 번째 동작 데이터 읽기

---

### 서보모터 제어 명령

#### 1. 서보모터 조회 (명령 코드: 88)

```
A9 9A 05 88 03 00 02 92 ED
```
조회 (서보모터 ID, 각도 반환)

#### 2. 서보모터 이동 (명령 코드: 86/88)

```
A9 9A 09 88 06 02 01 5A 00 E8 03 DF ED
```
2번 서보모터를 90도로 이동

```
A9 9A 09 88 06 02 01 B4 00 E8 03 39 ED
```
2번 서보모터를 180도로 이동

**명령 구조 설명**:
- `A9 9A`: 프레임 헤더
- `09`: 데이터 길이
- `88`: 명령 코드
- `06`: 파라미터 길이
- `02`: 서보모터 ID
- `01`: 서브 명령
- `5A 00`: 각도 (90도 = 0x005A)
- `E8 03`: 이동 시간 (1000ms = 0x03E8)
- `DF`: 체크섬
- `ED`: 프레임 종료

#### 3. ID 수정 (명령 코드: 89)

```
A9 9A 05 89 03 01 02 94 ED
```
1번 서보모터를 2번으로 수정 (01 → 02)

#### 4. 조회 (명령 코드: 88)

```
A9 9A 05 88 03 01 02 93 ED
```
1번 서보모터 조회

#### 5. 잠금 (명령 코드: 21)

```
A9 9A 03 21 02 26 ED
```
2번 서보모터 잠금

#### 6. 해제 (명령 코드: 22)

```
A9 9A 03 22 02 27 ED
```
2번 서보모터 해제

#### 7. 0도 설정 (명령 코드: 88)

```
A9 9A 07 88 04 02 0A 00 00 9F ED
```
2번 서보모터를 0도로 설정

#### 8. POS 재생 (명령 코드: 84)

```
A9 9A 05 84 06 00 01 90 ED
```
동작 그룹 6의 첫 번째 포즈 재생 [6, 1]

#### 9. 모든 서보모터 각도 조회 (명령 코드: 11)

```
A9 9A 02 11 13 ED
```
**응답**:
```
A9 9A 08 11 FF 00 B6 01 FF 00 CE ED
```
3개 서보모터의 데이터 패킷 반환 (서보모터 수에 따라 동적 계산)

#### 10. 다중 서보모터 다중 각도 제어 (명령 코드: 96)

**1개 서보모터**:
```
A9 9A 09 96 06 01 03 5A 00 E8 03 EE ED
```
3번 서보모터를 90도로 이동

**2개 서보모터**:
```
A9 9A 0C 96 09 02 02 03 5A 00 5A 00 E8 03 51 ED
```
2번, 3번 서보모터를 90도로 이동

**5개 서보모터**:
```
A9 9A 15 96 12 05 02 03 04 05 0E 5A 00 5A 00 5A 00 5A 00 5A 00 E8 03 8B ED
```
2번, 3번, 4번, 5번, 15번 서보모터를 90도로 이동

**명령 구조**:
- cmd[2]: 명령 총 길이 [체크섬 포함]
- cmd[4]: 명령 길이 [체크섬 미포함]
- cmd[5]: 서보모터 수량
- cmd[6~10]: ID1~ID5
- cmd[11]: ANGLE1_L (하위 바이트)
- cmd[12]: ANGLE1_H (상위 바이트)
- cmd[13~20]: ANGLE2~ANGLE5 (각 2바이트)
- cmd[21]: moveTime_L (하위 바이트)
- cmd[22]: moveTime_H (상위 바이트)

#### 11. 로봇 팔 LED 제어 (명령 코드: 97)

**왼손 LED**:
```
A9 9A 07 97 03 6F 07 A5 00 97 ED
```
6F(왼손) A5(흰색 깜박임)

**오른손 LED**:
```
A9 9A 07 97 03 6E 07 A2 00 B8 ED
```
6E(오른손) A2(빨간색 깜박임 후 상시 점등)

**명령 구조**:
- cmd[5]: ID
- cmd[7]: LED 데이터 (A0은 LED 끄기, 색상은 A1-B2까지 다양함)
- cmd[9]: 체크섬 값

**LED 색상 코드**:
- A0: LED 끄기
- A1: 파란색 상시 점등
- A2: 빨간색 깜박임
- A3: 노란색 깜박임
- A4: 녹색 깜박임
- A5: 흰색 상시 점등
- A6: 녹색 깜박임 (느림)
- A7: LED 끄기
- A8: 흰색 깜박임 (느림)
- A9: 노란색 깜박임 (느림)
- AA: 빨간색 깜박임 (느림)
- AD: 파란색 상시 점등
- AE: 녹색 상시 점등

---

## Arduino 프로그래밍 예제

프로그래밍은 매우 편리합니다.
프로그래밍을 통해 제어 보드를 관리하는 것은 매우 편리하며, 명령 하나만 보내면 제어할 수 있습니다.

### 예제 1: UNO 프로그래밍

소프트웨어 시리얼 사용

**배선**: V-V(5V), G-G, T-R, R-T

```cpp
#include <SoftwareSerial.h>

SoftwareSerial softser = SoftwareSerial(11, 12); // 소프트 시리얼
byte Cmd_1[7] = {0xA9, 0x9A, 0x03, 0x41, 0x02, 0x46, 0xED}; // 동작 그룹 2 재생
byte Cmd_2[6] = {0xA9, 0x9A, 0x02, 0x4F, 0x51, 0xED};       // 동작 그룹/동작 재생 중지

void setup() {
  softser.begin(115200);
  delay(10);
}

void loop() {
  softser.write(Cmd_1, 7);
  delay(1000 * 13);
  softser.write(Cmd_2, 6);
  delay(3);
}
```

---

### 예제 2: Mega2560 프로그래밍

시리얼3 사용

**배선**: V-V(5V), G-G, T-R, R-T

```cpp
#include <Arduino.h>

byte Cmd_1[7] = {0xA9, 0x9A, 0x03, 0x41, 0x02, 0x46, 0xED}; // 동작 그룹 2 재생
byte Cmd_2[6] = {0xA9, 0x9A, 0x02, 0x4F, 0x51, 0xED};       // 동작 그룹/동작 재생 중지
byte Cmd_3[13] = {0xA9, 0x9A, 0x09, 0x88, 0x06, 0x00, 0x01, 0x5A, 0x00, 0xF4, 0x01, 0xE7, 0xED}; // 2번 서보 90도
byte Cmd_4[13] = {0xA9, 0x9A, 0x09, 0x88, 0x06, 0x00, 0x01, 0xB4, 0x00, 0xF4, 0x01, 0x41, 0xED}; // 2번 서보 180도

void setup() {
  Serial3.begin(115200);
  delay(6000);
}

void loop() {
  for (int i = 0; i < 8; i++) {
    delay(8000);
    Serial3.write(Cmd_3, 13);
    delay(8000);
    Serial3.write(Cmd_4, 13);
    delay(8000);
  }
}
```

---

### 예제 3: PS2 컨트롤러

PS2 컨트롤러와 제어 보드를 UNO 보드에 연결

```cpp
#include <Arduino.h>
#include <SoftwareSerial.h>

// 소프트 시리얼 열기
SoftwareSerial softser = SoftwareSerial(11, 12);      // UNO 보드, PS2 컨트롤러 IO 연결
SoftwareSerial ubx_softSerial(7, 8);                 // RX, TX - UNO 보드, 제어 보드 IO 연결
#define my_serial ubx_softSerial

int temp_char;

void setup() {
  Serial.begin(115200);      // UNO 하드웨어 시리얼, 사용 안 함
  my_serial.begin(115200);   // 제어 보드용
  softser.begin(115200);     // PS2 컨트롤러용
}

void loop() {
  if (softser.available() > 0) {
    temp_char = char(softser.read());
    
    if (temp_char == 73) {
      byte Cmd_Play_Action5059121[7] = {0xA9, 0x9A, 0x03, 0x41, 0x04, 0x48, 0xED};
      my_serial.write(Cmd_Play_Action5059121, 7);
    }
    
    if (temp_char == 74) {
      byte Cmd_stop_play6233962[6] = {0xA9, 0x9A, 0x02, 0x4F, 0x51, 0xED};
      my_serial.write(Cmd_stop_play6233962, 6);
    }
    
    if (temp_char == 66) {
      byte Cmd_move_angle2531870[13] = {0xA9, 0x9A, 0x09, 0x88, 0x06, 0x02, 0x01, 0x00, 0x00, 0xF4, 0x01, 0x8F, 0xED};
      my_serial.write(Cmd_move_angle2531870, 13);
    }
    
    if (temp_char == 68) {
      byte Cmd_move_angle7083652[13] = {0xA9, 0x9A, 0x09, 0x88, 0x06, 0x02, 0x01, 0x5A, 0x00, 0xF4, 0x01, 0xE9, 0xED};
      my_serial.write(Cmd_move_angle7083652, 13);
    }
    
    if (temp_char == 65) {
      byte Cmd_move_angle8494327[13] = {0xA9, 0x9A, 0x09, 0x88, 0x06, 0x02, 0x01, 0xB4, 0x00, 0xF4, 0x01, 0x43, 0xED};
      my_serial.write(Cmd_move_angle8494327, 13);
    }
    
    if (temp_char == 67) {
      byte Cmd_move_angle2812049[13] = {0xA9, 0x9A, 0x09, 0x88, 0x06, 0x02, 0x01, 0x0E, 0x01, 0xF4, 0x01, 0x9E, 0xED};
      my_serial.write(Cmd_move_angle2812049, 13);
    }
  }
}
```

---

### 예제 4: 라즈베리파이 프로그래밍

라즈베리파이와 제어 보드 통신 예제

**연결**: USB 케이블 한쪽 끝을 라즈베리파이에, 다른 쪽 끝을 제어 보드에 연결 [또는 보드의 노란색 핀 헤더에 연결]

**시리얼 포트**: `/dev/ttyUSB0` 사용 [실제 상황에 따라 설정하십시오]

```python
import serial
import time
import binascii

s = serial.Serial('/dev/ttyUSB0', 115200)

# 각도 명령 정의
angle_90  = [0xA9, 0x9A, 0x09, 0x88, 0x06, 0x00, 0x01, 0x5A, 0x00, 0xE8, 0x03, 0xDD, 0xED]  # 90도
angle_180 = [0xA9, 0x9A, 0x09, 0x88, 0x06, 0x00, 0x01, 0xB4, 0x00, 0xE8, 0x03, 0x37, 0xED]  # 180도
angle_270 = [0xA9, 0x9A, 0x09, 0x88, 0x06, 0x00, 0x01, 0x0E, 0x01, 0xE8, 0x03, 0x92, 0xED]  # 270도
angle_360 = [0xA9, 0x9A, 0x09, 0x88, 0x06, 0x00, 0x01, 0x67, 0x01, 0xE8, 0x03, 0x09, 0xED]  # 360도
play_id_hex = [0xA9, 0x9A, 0x03, 0x41, 0x03, 0x47, 0xED]  # 동작 그룹 3 재생

# 먼저 다른 동작 중지
s.write(b'\xA9\x9A\x02\x4F\x51\xED')

# 순차적으로 각도 이동
senddata = angle_90
s.write(senddata)
time.sleep(2)

senddata = angle_180
s.write(senddata)
time.sleep(2)

senddata = angle_270
s.write(senddata)
time.sleep(2)

senddata = angle_360
s.write(senddata)
time.sleep(2)

# 동작 그룹 재생 (필요시 주석 해제)
# senddata = play_id_hex
# s.write(senddata)
# time.sleep(2)

s.close()
```

---

## 시교 동작 그룹

시교(Teaching) 기능은 두 가지 상황으로 나뉩니다:

### 첫 번째: 컴퓨터에서 상위기 소프트웨어로 작업

제공된 자료 패키지에 작업 비디오 자료가 있습니다.

### 두 번째: 오프라인 시교

적외선 리모컨 작동과 결합하여 매우 편리합니다.
여기서는 두 번째 방식의 구현에 대해 논의합니다.

#### 설정 방법

상위기 소프트웨어 오른쪽에서 차례로 클릭:
**주 제어 보드 → 특수 동작 → 이벤트 처리 시스템**

**기본 설정**: 시교 동작 그룹은 6번으로 설정 [직접 수정 가능]
편집 과정 중 OLED 화면에 동작 그룹 ID 번호와 몇 번째 레코드인지 표시됩니다.

#### 적외선 리모컨 설정

- **`*`**: 모든 서보모터 해제 [서보모터 해제 후에만 관절을 움직일 수 있음]
- **`OK`**: 시교 동작에 1개의 Pos 레코드 추가
- **`4`**: 동작 그룹 6번 삭제 [동작이 만족스럽지 않으면 이 명령으로 동작 그룹 삭제 후 다시 시작]
- **`6`**: 동작 그룹 6번 재생 [방금 편집한 동작 그룹 재생]

"이벤트 처리 시스템"에 블록 설정이 로드되지 않은 경우, "이벤트 처리 시스템" 창 왼쪽 하단의 "파일 로드"를 클릭하여 "시교_동작_그룹_디버그" 파일을 선택하여 수동으로 로드할 수 있습니다.

#### 시교 과정 (기본적으로 6번 동작 그룹에 바인딩)

1. **`*` 키 누름**: 모든 서보모터 해제
2. **손으로 서보모터 관절을 지정된 위치로 이동**
3. **`OK` 키 누름**: 1프레임 동작 데이터 추가
4. **2, 3단계 반복**: 동작 그룹 편집 완료까지
5. **`6` 키 누름**: 방금 편집한 6번 동작 그룹 확인

동작이 만족스럽지 않으면 **`4` 키**를 눌러 해당 6번 동작 그룹을 삭제하고 다시 시교할 수 있습니다.

편집이 완료되면 더 세밀한 조정이 필요한 경우 상위기 소프트웨어에서 작업할 수 있습니다.

---

## 펌웨어 업그레이드

정상적으로 사용하는 과정에서 새로운 기능을 경험하고 싶지 않은 경우 펌웨어를 업그레이드하지 않을 수 있습니다. 때때로 새로운 펌웨어 프로그램은 해당 상위기 소프트웨어를 업데이트해야 합니다. **(업데이트 여부를 신중히 고려하십시오.)**

### 펌웨어 업데이트 방법

1. 상위기 소프트웨어 왼쪽 상단 메뉴에서 선택:
   **파일 → 로봇 펌웨어 쓰기**

2. 펌웨어 쓰기 창이 나타나면:
   - 창 왼쪽에서 제어 보드에 해당하는 시리얼 포트 선택
   - 온라인 업그레이드 실행

---

## 주의사항

1. **전원**: 반드시 24V 3A 이상의 전원 또는 6S 배터리 팩 사용
2. **배선**: CANH와 CANL을 정확하게 연결
3. **서보모터 ID**: 각 서보모터는 고유한 ID를 가져야 함
4. **체크섬**: 모든 명령은 올바른 체크섬 값을 포함해야 함
5. **보드 레이트**: 115200bps로 설정

---

## 트러블슈팅

### 서보모터가 응답하지 않음
- 전원 연결 확인
- 배선 확인 (특히 CANH, CANL)
- 서보모터 ID 확인
- 명령 형식 및 체크섬 확인

### 동작이 부정확함
- 시교 과정을 다시 수행
- 상위기 소프트웨어에서 세밀한 조정
- 서보모터 0점 설정 확인

### 통신 오류
- 보드 레이트 확인 (115200bps)
- 시리얼 포트 번호 확인
- 케이블 연결 상태 확인

---

*본 문서는 학습 및 교류 목적으로만 사용하며, 상업적 용도는 금지합니다.*