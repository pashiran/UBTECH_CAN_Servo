# UBTECH 서보 CAN 버스 프로토콜

## 목차
- [프로토콜 개요](#프로토콜-개요)
- [하드웨어 사양](#하드웨어-사양)
- [통신 설정](#통신-설정)
- [프레임 구조](#프레임-구조)
- [명령어 전체 목록](#명령어-전체-목록)
- [상세 명령어 설명](#상세-명령어-설명)
- [예제 코드](#예제-코드)
- [트러블슈팅](#트러블슈팅)

---

## 프로토콜 개요

### 적용 대상
- **UBTECH 60kg 서보모터** (1세대 Cruzr 로봇 팔)
- **UBTECH 25kg 서보모터** (1세대 Cruzr 로봇 팔)

⚠️ **중요**: 서보 펌웨어 버전에 따라 프로토콜이 2가지 형태로 존재합니다.

### 프로토콜 변종

#### 프로토콜 타입 A (문서 사양)
- **CAN 속도**: 500 kbps
- **명령 전송**: 16바이트 논리 패킷 (2개의 8바이트 CAN 프레임)
- **응답 수신**: 16바이트 논리 패킷 (헤더 `AA 00 00` 포함)
- **적용**: 초기 펌웨어 버전 또는 특정 서보 모델

#### 프로토콜 타입 B (실제 테스트 결과) ⭐
- **CAN 속도**: **1 Mbps (1000 kbps)**
- **명령 전송**: 16바이트 논리 패킷 (2개의 8바이트 CAN 프레임)
- **응답 수신**: **단일 8바이트 CAN 프레임 (헤더 없음)**
- **적용**: 테스트된 서보 (ID=14, HW=0x62, SW=0x60)
- **테스트 일자**: 2025-11-23

### 주요 특징
- **통신 방식**: CAN 2.0 프로토콜
- **제어 코어**: ARM 32비트 마이크로컨트롤러
- **위치 감지**: 360도 12비트 정밀도 자기 감지 각도 센서
- **각도 정밀도**: 0.09도 (360° ÷ 4096)
- **각도 제어 범위**: 0-360도
- **속도 제어 범위**: 0-280도/s
- **속도 제어 정밀도**: 1도/s

### 프레임 형식
- **프레임 헤더**: `AA 00 00`
- **데이터 길이**: 고정 8바이트
- **바이트 순서**: Little-Endian (하위 바이트 먼저)

---

## 하드웨어 사양

### 전원 요구사항
- **권장 전원**: 24V 3A 이상
- **대체 전원**: 6S 리튬 배터리 팩 (18650 × 6개)

### 핀 배치 (4핀 5264 커넥터)
| 핀 번호 | 신호명 | 설명 |
|---------|--------|------|
| 1 | V+ | 전원 (+24V) |
| 2 | GND | 접지 |
| 3 | CANH | CAN High |
| 4 | CANL | CAN Low |

⚠️ **주의**: 노치(홈) 위치에 맞춰 정확하게 배선하세요.

### 필요 장비
- USB to CAN 모듈
- 24V 전원 공급장치
- 배선 단자 및 케이블

---

## 통신 설정

### CAN 버스 파라미터

| 파라미터 | 타입 A (문서) | 타입 B (테스트) |
|----------|---------------|-----------------|
| 통신 속도 | 500 kbps | **1 Mbps** ⭐ |
| 프레임 형식 | 표준 프레임 (11-bit ID) | 표준 프레임 (11-bit ID) |
| 데이터 길이 | 8 바이트 고정 | 8 바이트 고정 |

⚠️ **통신 실패 시**: 500 kbps와 1 Mbps를 모두 시도하세요.

### 버스 구성
- 하나의 CAN 버스에 여러 서보 연결 가능
- 각 서보는 고유한 ID 보유 (1-240)
- ID 0은 브로드캐스트 주소 (모든 서보에 명령 전달)

---

## 프레임 구조

### 공통 사항 (타입 A & B)

**명령 전송 (호스트 → 서보):**
- 16바이트 논리 패킷을 **2개의 8바이트 CAN 프레임**으로 분할 전송

| CAN 프레임 | 내용 |
|-----------|------|
| Frame 1 | `AA 00 00 [LEN] 00 00 00 [ID]` |
| Frame 2 | `[CMD] [DATA0] [DATA1] [DATA2] [DATA3] [DATA4] [DATA5] [DATA6]` |

---

### 프로토콜 타입 A (문서 사양)

**응답 수신 (서보 → 호스트):**
- 16바이트 논리 패킷 (2개의 8바이트 CAN 프레임)
- **헤더 포함** (`AA 00 00`)

| CAN 프레임 | 내용 |
|-----------|------|
| Frame 1 | `AA 00 00 [LEN] 00 00 00 [ID]` |
| Frame 2 | `[CMD] [DATA0] [DATA1] [DATA2] [DATA3] [DATA4] [DATA5] [DATA6]` |

예시 (정보 읽기 응답):
```
Frame 1: AA 00 00 08 00 00 00 0D
Frame 2: 02 03 08 62 60 17 10 10
         └─ 응답코드
            └──┴── 위치 (Little-Endian)
                  └─ HW 버전
                     └─ SW 버전
```

---

### 프로토콜 타입 B (실제 테스트) ⭐

**응답 수신 (서보 → 호스트):**
- **단일 8바이트 CAN 프레임**
- **헤더 없음**

| 바이트 | 내용 | 설명 |
|--------|------|------|
| 0 | 응답 코드 | 0x02 (정보), 0x08 (ID 관련) 등 |
| 1-7 | 데이터 | 명령에 따른 응답 데이터 |

예시 (정보 읽기 응답):
```
명령: ID 조회 (0x01)
  TX Frame 1: AA 00 00 01 00 00 00 00
  TX Frame 2: 01 00 00 00 00 00 00 00

응답:
  RX Frame:   02 F6 07 62 60 17 10 10
              └─ 응답코드
                 └──┴── 위치 (Little-Endian)
                       └─ HW 버전
                          └─ SW 버전
```

---

### 문서 사양 (타입 A - 참고용)

### 명령 패킷 (호스트 → 서보)

| 바이트 | 내용 | 설명 |
|--------|------|------|
| 0 | 0xAA | 프레임 헤더 1 |
| 1 | 0x00 | 프레임 헤더 2 |
| 2 | 0x00 | 프레임 헤더 3 |
| 3 | Length | 데이터 길이 (payload) |
| 4 | 0x00 | 예약 |
| 5 | 0x00 | 예약 |
| 6 | 0x00 | 예약 |
| 7 | ID | 서보 ID (0=전체, 1-240) |
| 8 | CMD | 명령 코드 |
| 9-15 | Data | 명령별 파라미터 |

### 응답 패킷 (서보 → 호스트)

| 바이트 | 내용 | 설명 |
|--------|------|------|
| 0 | 0xAA | 프레임 헤더 1 |
| 1 | 0x00 | 프레임 헤더 2 |
| 2 | 0x00 | 프레임 헤더 3 |
| 3 | Length | 데이터 길이 |
| 4-6 | 0x00 | 예약 |
| 7 | ID | 응답한 서보 ID |
| 8 | CMD | 명령 코드 (에코) |
| 9-15 | Data | 응답 데이터 |

---

## 명령어 전체 목록

### 제어 명령

| 명령 코드 | 명령명 | 기능 | 파라미터 길이 | 응답 |
|-----------|--------|------|---------------|------|
| 0x01 | 정보 읽기 | ID 및 위치 조회 | 0 | 위치, 버전 정보 |
| 0x03 | 운동 제어 | 위치 및 속도 제어 | 4 | 상태 코드 |
| 0x07 | ID 수정 | 서보 ID 변경 | 5 | 새 ID, 고유 코드 |
| 0x11 | 잠금 | 서보 잠금 (토크 유지) | 0 | 확인 |
| 0x2F | 해제 | 서보 해제 (토크 제거) | 0 | 확인 |

### 상태 코드

| 코드 | 의미 | 설명 |
|------|------|------|
| 0xAA | 정상 | 명령 정상 실행 |
| 0xBB | 과속 경고 | 요청 속도가 최대값 초과 |
| 0xCC | 제한 경고 | 각도가 범위를 벗어남 |
| 0x04 | 실행 중 | 명령 실행 중 |
| 0x06 | 오류 | 명령 실행 실패 |

---

## 상세 명령어 설명

### 1. 정보 읽기 (0x01)

**기능**: CAN 버스의 모든 서보 또는 특정 서보의 현재 위치와 버전을 조회

---

#### 명령 전송 (공통)

**송신 프레임**
```
Frame 1: AA 00 00 01 00 00 00 [ID]
Frame 2: 01 00 00 00 00 00 00 00
```

| 필드 | 값 | 설명 |
|------|-----|------|
| Frame 1 바이트 0-2 | AA 00 00 | 프레임 헤더 |
| Frame 1 바이트 3 | 0x01 | 데이터 길이 |
| Frame 1 바이트 7 | ID | 0x00=전체, 또는 특정 ID |
| Frame 2 바이트 0 | 0x01 | 명령 코드 |
| Frame 2 바이트 1-7 | 0x00 | 파라미터 없음 |

---

#### 응답 수신 (타입 B - 실제 테스트) ⭐

**수신 프레임**
```
02 [POS_L] [POS_H] [HW_VER] [SW_VER] [XX] [XX] [XX]
```

| 필드 | 설명 |
|------|------|
| 바이트 0 | 0x02 (응답 코드) |
| 바이트 1-2 | 현재 위치 (Little-Endian, 0-4095) |
| 바이트 3 | 하드웨어 버전 |
| 바이트 4 | 소프트웨어 버전 |
| 바이트 5-7 | 추가 데이터 |

---

#### 응답 수신 (타입 A - 문서 사양)

**수신 프레임**
```
Frame 1: AA 00 00 08 00 00 00 [ID]
Frame 2: 02 [POS_L] [POS_H] [HW_VER] [SW_VER] XX XX XX
```

| 필드 | 설명 |
|------|------|
| Frame 1 바이트 7 | 응답한 서보 ID |
| Frame 2 바이트 0 | 0x02 (응답 코드) |
| Frame 2 바이트 1-2 | 현재 위치 (Little-Endian, 0-4095) |
| Frame 2 바이트 3 | 하드웨어 버전 |
| Frame 2 바이트 4 | 소프트웨어 버전 |

#### 위치 계산
```
각도 = (위치 값 × 360) ÷ 4096
예: 위치 = 2048 → 각도 = (2048 × 360) ÷ 4096 = 180도
```

#### 예제

**타입 B - 실제 테스트 (ID 14 서보 조회)**
```
송신 Frame 1: AA 00 00 01 00 00 00 00  (브로드캐스트)
송신 Frame 2: 01 00 00 00 00 00 00 00
수신:         02 F6 07 62 60 17 10 10
```
- 위치: 0x07F6 = 2038 (Little-Endian) → 약 179.0도
- HW 버전: 0x62
- SW 버전: 0x60

**타입 A - 문서 사양 (ID 13 서보 조회)**
```
송신 Frame 1: AA 00 00 01 00 00 00 0D
송신 Frame 2: 01 00 00 00 00 00 00 00
수신 Frame 1: AA 00 00 08 00 00 00 0D
수신 Frame 2: 02 03 08 62 60 17 10 10
```
- 위치: 0x0803 = 2051 (Little-Endian) → 약 180.3도
- HW 버전: 0x62
- SW 버전: 0x60

---

### 2. 운동 제어 (0x03)

**기능**: 서보를 지정된 각도로 지정된 속도로 이동

---

#### 명령 전송 (공통)

**송신 프레임**
```
Frame 1: AA 00 00 05 00 00 00 [ID]
Frame 2: 03 [POS_L] [POS_H] [SPD_L] [SPD_H] 00 00 00
```

| 필드 | 값 | 설명 |
|------|-----|------|
| Frame 1 바이트 0-2 | AA 00 00 | 프레임 헤더 |
| Frame 1 바이트 3 | 0x05 | 데이터 길이 |
| Frame 1 바이트 7 | ID | 대상 서보 ID |
| Frame 2 바이트 0 | 0x03 | 명령 코드 |
| Frame 2 바이트 1-2 | 위치 | 목표 각도 (0-4095) |
| Frame 2 바이트 3-4 | 속도 | 이동 속도 (0-280 deg/s) |
| Frame 2 바이트 5-7 | 0x00 | 예약 |

---

#### 응답 수신 (타입 B)

서보가 명령을 받으면 상태 코드로 응답합니다 (응답 형식은 구현에 따라 다를 수 있음).

---

#### 응답 수신 (타입 A - 문서 사양)

**수신 프레임**
```
Frame 1: AA 00 00 03 00 00 00 [ID]
Frame 2: 03 [STATUS] AA [POS_L] [POS_H] 00 00 00
```

| 필드 | 설명 |
|------|------|
| Frame 2 바이트 1 | 상태 코드 (0x04=실행중, 0xAA=완료) |
| Frame 2 바이트 2 | 0xAA (정상) |
| Frame 2 바이트 3-4 | 현재 위치 |

#### 각도 및 속도 계산

**각도 → 위치 값**
```
위치 값 = (각도 × 4096) ÷ 360
예: 180도 → (180 × 4096) ÷ 360 = 2048 (0x0800)
    Little-Endian: 0x00 0x08
```

**속도 값**
```
속도 값 = 속도 (deg/s)
예: 150 deg/s → 0x96 0x00 (Little-Endian)
```

#### 예제

**타입 B - 실제 테스트 (ID 1 서보를 180도로 100deg/s)**
```
송신 Frame 1: AA 00 00 05 00 00 00 01
송신 Frame 2: 03 00 08 64 00 00 00 00
```
- 위치: 0x0800 = 2048 → 180도
- 속도: 0x0064 = 100 deg/s

**타입 A - 문서 사양 (ID 13 서보를 180도로 150deg/s)**
```
송신 Frame 1: AA 00 00 05 00 00 00 0D
송신 Frame 2: 03 00 08 96 00 00 00 00
수신 Frame 1: AA 00 00 03 00 00 00 0D
수신 Frame 2: 03 04 AA 96 00 00 00 00
```
- 위치: 0x0800 = 2048 → 180도
- 속도: 0x0096 = 150 deg/s

---

### 3. ID 수정 (0x07)

**기능**: 서보의 ID를 변경 (고유 코드 필요)

#### 3.1 고유 코드 조회

**송신 프레임**
```
Frame 1: AA 00 00 01 00 00 00 [OLD_ID]
Frame 2: 07 00 00 00 00 00 00 00
```

**수신 프레임 (실제)**
```
08 00 [CODE1] [CODE2] [CODE3] [CODE4] [XX] [XX]
```

| 필드 | 설명 |
|------|------|
| 바이트 0 | 0x08 (고유 코드 응답) |
| 바이트 2-5 | 4바이트 고유 코드 |

**수신 프레임 (문서 사양)**
```
AA 00 00 06 00 00 00 [OLD_ID] 08 00 [CODE1] [CODE2] [CODE3] [CODE4] XX XX
```

| 필드 | 설명 |
|------|------|
| 바이트 8 | 0x08 (고유 코드 응답) |
| 바이트 10-13 | 4바이트 고유 코드 |

#### 3.2 ID 변경

**송신 프레임**
```
Frame 1: AA 00 00 06 00 00 00 [OLD_ID]
Frame 2: 07 [NEW_ID] [CODE1] [CODE2] [CODE3] [CODE4] 00 00
```

**수신 프레임 (실제)**
```
08 [NEW_ID] [CODE1] [CODE2] [CODE3] [CODE4] [XX] [XX]
```

**수신 프레임 (문서 사양)**
```
AA 00 00 02 00 00 00 [NEW_ID] 08 [NEW_ID] [CODE1] [CODE2] [CODE3] [CODE4] XX XX
```

#### 예제
**ID 1을 ID 5로 변경 (실제 테스트)**

1. 고유 코드 조회
```
송신 Frame 1: AA 00 00 01 00 00 00 01
송신 Frame 2: 07 00 00 00 00 00 00 00
수신:         08 00 5A 8A 8C 74 XX XX
```
- 고유 코드: 5A 8A 8C 74

2. ID 변경
```
송신 Frame 1: AA 00 00 06 00 00 00 01
송신 Frame 2: 07 05 5A 8A 8C 74 00 00
수신:         08 05 5A 8A 8C 74 XX XX
```
- 새 ID: 0x05

**문서 사양 예제 (참고)**

1. 고유 코드 조회
```
송신: AA 00 00 01 00 00 00 0D 07 00 00 00 00 00 00 00
수신: AA 00 00 06 00 00 00 0D 08 00 5A 8A 8C 74 10 10
```
- 고유 코드: 5A 8A 8C 74

2. ID 변경
```
송신: AA 00 00 06 00 00 00 0D 07 03 5A 8A 8C 74 00 00
수신: AA 00 00 02 00 00 00 03 08 03 5A 8A 8C 74 10 10
```
- 새 ID: 0x03

⚠️ **주의**: 브로드캐스트(ID=0)로 ID 변경 시 버스에 서보가 하나만 있어야 합니다.

---

### 4. 잠금 (0x11)

**기능**: 서보를 현재 위치에서 잠금 (토크 유지)

#### 송신 프레임
```
Frame 1: AA 00 00 01 00 00 00 [ID]
Frame 2: 11 00 00 00 00 00 00 00
```

#### 수신 프레임 (실제)
```
12 [ID] [CODE1] [CODE2] [CODE3] [CODE4] [XX] [XX]
```

#### 수신 프레임 (문서 사양)
```
AA 00 00 01 00 00 00 [ID] 12 [ID] [CODE1] [CODE2] [CODE3] [CODE4] XX XX
```

#### 동작
- 서보가 현재 위치를 유지하며 외력에 저항
- 외력이 최대 토크를 초과하지 않는 한 움직이지 않음
- 전원 공급 유지

#### 예제
```
송신 Frame 1: AA 00 00 01 00 00 00 01
송신 Frame 2: 11 00 00 00 00 00 00 00
수신:         12 01 5A 8A 8C 74 XX XX
```

**문서 사양 예제 (참고)**
```
송신: AA 00 00 01 00 00 00 0D 11 00 00 00 00 00 00 00
수신: AA 00 00 01 00 00 00 0D 12 0D 5A 8A 8C 74 10 10
```

---

### 5. 해제 (0x2F)

**기능**: 서보 잠금 해제 (토크 제거)

#### 송신 프레임
```
Frame 1: AA 00 00 01 00 00 00 [ID]
Frame 2: 2F 00 00 00 00 00 00 00
```

#### 수신 프레임 (실제)
```
30 [ID] [CODE1] [CODE2] [CODE3] [CODE4] [XX] [XX]
```

#### 수신 프레임 (문서 사양)
```
AA 00 00 01 00 00 00 [ID] 30 [ID] [CODE1] [CODE2] [CODE3] [CODE4] XX XX
```

#### 동작
- 서보의 토크가 제거됨
- 외력에 의해 자유롭게 움직임 (기어 저항만 존재)
- 전원 소비 최소화

#### 예제
```
송신 Frame 1: AA 00 00 01 00 00 00 01
송신 Frame 2: 2F 00 00 00 00 00 00 00
수신:         30 01 5A 8A 8C 74 XX XX
```

**문서 사양 예제 (참고)**
```
송신: AA 00 00 01 00 00 00 0D 2F 00 00 00 00 00 00 00
수신: AA 00 00 01 00 00 00 0D 30 0D 5A 8A 8C 74 10 10
```

---

## 예제 코드

### Python 예제

```python
import can
import struct

class UBTechServo:
    def __init__(self, bus_channel='can0', bitrate=500000):
        """CAN 버스 초기화"""
        self.bus = can.interface.Bus(
            channel=bus_channel,
            bustype='socketcan',
            bitrate=bitrate
        )
    
    def send_command(self, servo_id, cmd, data):
        """CAN 명령 전송"""
        # 프레임 구성
        msg_data = [0xAA, 0x00, 0x00, len(data)+1, 
                    0x00, 0x00, 0x00, servo_id, cmd] + data
        # 8바이트로 패딩
        msg_data.extend([0x00] * (8 - len(msg_data) % 8))
        
        msg = can.Message(
            arbitration_id=0x00,
            data=msg_data[:8],
            is_extended_id=False
        )
        self.bus.send(msg)
        
    def read_position(self, servo_id=0):
        """위치 읽기 (ID=0이면 전체)"""
        self.send_command(servo_id, 0x01, [0x00]*6)
        
        # 응답 대기
        msg = self.bus.recv(timeout=1.0)
        if msg:
            # 위치 추출 (Little-Endian)
            pos_raw = msg.data[9] | (msg.data[10] << 8)
            angle = (pos_raw * 360) / 4096
            return angle
        return None
    
    def move_to_angle(self, servo_id, angle, speed=100):
        """지정 각도로 이동
        
        Args:
            servo_id: 서보 ID (1-240)
            angle: 목표 각도 (0-360)
            speed: 속도 (0-280 deg/s)
        """
        # 각도를 위치 값으로 변환
        pos_raw = int((angle * 4096) / 360)
        pos_l = pos_raw & 0xFF
        pos_h = (pos_raw >> 8) & 0xFF
        
        # 속도 값
        spd_l = speed & 0xFF
        spd_h = (speed >> 8) & 0xFF
        
        data = [pos_l, pos_h, spd_l, spd_h, 0x00, 0x00]
        self.send_command(servo_id, 0x03, data)
    
    def lock_servo(self, servo_id):
        """서보 잠금"""
        self.send_command(servo_id, 0x11, [0x00]*6)
    
    def unlock_servo(self, servo_id):
        """서보 해제"""
        self.send_command(servo_id, 0x2F, [0x00]*6)
    
    def change_id(self, old_id, new_id):
        """ID 변경"""
        # 1. 고유 코드 조회
        self.send_command(old_id, 0x07, [0x00]*6)
        msg = self.bus.recv(timeout=1.0)
        
        if msg:
            # 고유 코드 추출
            unique_code = msg.data[10:14]
            
            # 2. ID 변경
            data = [new_id] + list(unique_code) + [0x00]
            self.send_command(old_id, 0x07, data)
            print(f"ID {old_id} → {new_id} 변경 완료")

# 사용 예제
if __name__ == "__main__":
    servo = UBTechServo()
    
    # 위치 읽기
    angle = servo.read_position(servo_id=1)
    print(f"현재 각도: {angle}도")
    
    # 90도로 이동
    servo.move_to_angle(servo_id=1, angle=90, speed=150)
    
    # 3초 대기 후 180도로 이동
    import time
    time.sleep(3)
    servo.move_to_angle(servo_id=1, angle=180, speed=100)
```

### Arduino 예제

```cpp
#include <mcp_can.h>
#include <SPI.h>

#define CAN_CS_PIN 10

MCP_CAN CAN(CAN_CS_PIN);

void setup() {
    Serial.begin(115200);
    
    // CAN 초기화 (500kbps)
    while (CAN.begin(MCP_ANY, CAN_500KBPS, MCP_8MHZ) != CAN_OK) {
        Serial.println("CAN 초기화 실패!");
        delay(100);
    }
    CAN.setMode(MCP_NORMAL);
    
    Serial.println("CAN 초기화 완료");
}

void sendCommand(byte servoID, byte cmd, byte* data, int dataLen) {
    byte buf[8] = {0xAA, 0x00, 0x00, dataLen+1, 0x00, 0x00, 0x00, servoID};
    
    // 첫 프레임 전송
    CAN.sendMsgBuf(0x00, 0, 8, buf);
    
    // 두 번째 프레임 (명령 + 데이터)
    byte buf2[8] = {cmd};
    for(int i = 0; i < dataLen && i < 7; i++) {
        buf2[i+1] = data[i];
    }
    CAN.sendMsgBuf(0x00, 0, 8, buf2);
}

void moveServo(byte id, int angle, int speed) {
    // 각도를 위치 값으로 변환
    int posRaw = (angle * 4096) / 360;
    
    byte data[6];
    data[0] = posRaw & 0xFF;        // 위치 하위
    data[1] = (posRaw >> 8) & 0xFF; // 위치 상위
    data[2] = speed & 0xFF;         // 속도 하위
    data[3] = (speed >> 8) & 0xFF;  // 속도 상위
    data[4] = 0x00;
    data[5] = 0x00;
    
    sendCommand(id, 0x03, data, 6);
}

void readPosition(byte id) {
    byte data[6] = {0};
    sendCommand(id, 0x01, data, 6);
}

void lockServo(byte id) {
    byte data[6] = {0};
    sendCommand(id, 0x11, data, 6);
}

void unlockServo(byte id) {
    byte data[6] = {0};
    sendCommand(id, 0x2F, data, 6);
}

void loop() {
    // ID 1 서보를 90도로 이동
    moveServo(1, 90, 150);
    delay(3000);
    
    // 180도로 이동
    moveServo(1, 180, 150);
    delay(3000);
    
    // 0도로 이동
    moveServo(1, 0, 150);
    delay(3000);
}
```

---

## 트러블슈팅

### 서보가 응답하지 않음

**원인 및 해결책**:
1. **전원 문제**
   - 24V 전원이 정상적으로 공급되는지 확인
   - 전류 용량이 충분한지 확인 (최소 3A)

2. **배선 문제**
   - CANH와 CANL이 올바르게 연결되었는지 확인
   - 노치(홈) 방향 확인
   - 케이블 단선 여부 확인

3. **통신 설정**
   - **CAN 속도: 1 Mbps 먼저 시도** ⭐ (실제 서보가 사용)
   - CAN 속도: 500 kbps (문서 사양, fallback)
   - 프레임 형식: 표준 프레임
   - 터미네이션 저항 확인 (120Ω)

4. **서보 ID**
   - 브로드캐스트(ID=0)로 조회 시도
   - ID가 변경되었을 가능성 확인

5. **MCP2515 모듈 확인**
   - CAN 트랜시버 칩이 있는지 확인 (TJA1050, MCP2551 등)
   - CANH/CANL 전압 측정:
     - 정상: CANH 2.5~3.5V, CANL 1.5~2.5V
     - 비정상: 둘 다 같은 전압(예: 6V) → 트랜시버 불량

### 동작이 부정확함

1. **각도 오프셋**
   - 서보의 기계적 영점과 전기적 영점의 차이
   - 각도 오프셋 보정 필요 (별도 명령)

2. **속도 제한**
   - 최대 속도: 280 deg/s
   - 과도한 속도 설정 시 0xBB 경고

3. **각도 범위**
   - 유효 범위: 0-360도
   - 범위 초과 시 0xCC 경고

### 통신 오류

1. **프레임 오류**
   - 프레임 헤더 확인: AA 00 00
   - 데이터 길이 필드 확인
   - Little-Endian 바이트 순서 확인

2. **버스 충돌**
   - 여러 장치가 동시에 전송하는 경우
   - 명령 간 충분한 지연 시간 확보 (최소 10ms)

3. **고유 코드 오류**
   - ID 변경 시 정확한 고유 코드 사용
   - 고유 코드는 서보마다 다름

### 과열 문제

1. **1세대 vs 2세대**
   - 1세대 서보 권장 (발열 적음)
   - 2세대 서보는 발열량이 높아 비권장

2. **부하 관리**
   - 과도한 부하 시 전류 증가
   - 적절한 냉각 시스템 구성

### 기타 문제

1. **여러 서보 동시 제어**
   - 명령 간 충분한 시간 간격
   - 브로드캐스트 사용 시 주의

2. **전원 재시작**
   - 서보가 응답하지 않을 때 전원 재시작
   - 펌웨어 초기화 대기 (약 2초)

---

## 참고사항

### 실제 구현과 문서 사양의 차이점

**테스트 결과 (2025-11-23):**

서보 펌웨어 버전에 따라 2가지 프로토콜 타입이 존재합니다:

| 항목 | 타입 A (문서 사양) | 타입 B (실제 테스트) |
|------|-------------------|---------------------|
| **CAN 속도** | 500 kbps | **1 Mbps** ⭐ |
| **명령 전송** | 2개 CAN 프레임 (16바이트) | 2개 CAN 프레임 (16바이트) |
| **응답 수신** | 2개 CAN 프레임 (헤더 포함) | **단일 프레임 (헤더 없음)** |
| **응답 형식** | `AA 00 00 [LEN] ... [ID] [CMD] [DATA]` | `[CMD] [DATA]` |
| **테스트 서보** | - | ID=14, HW=0x62, SW=0x60 |

**프로토콜 구분 방법:**
1. **1 Mbps에서 통신 시도** → 성공하면 타입 B
2. **응답 헤더 확인** → 헤더 없으면 타입 B, 있으면 타입 A
3. **500 kbps fallback** → 타입 A 가능성

**중요:**
- 통신 실패 시 **반드시 두 속도(1 Mbps, 500 kbps) 모두 시도**
- MCP2515 트랜시버 불량 시 CANH/CANL 전압 비정상 (둘 다 같은 전압)

### 바이트 순서 (Endianness)
- 이 프로토콜은 **Little-Endian** 사용
- 16비트 값: 하위 바이트가 먼저, 상위 바이트가 나중
- 예: 0x0800 → 전송 시 [0x00, 0x08]

### 위치 인코딩
- 12비트 정밀도: 0-4095 (0xFFF)
- 360도를 4096으로 나눔
- 1 LSB = 0.0879도

### 속도 단위
- 직접 deg/s로 표현
- 범위: 0-280
- 0이면 최대 속도

### 고유 코드
- 각 서보는 4바이트 고유 코드 보유
- ID 변경 시 보안을 위해 사용
- 서보마다 고유함

### 브로드캐스트
- ID=0으로 설정 시 모든 서보에 전송
- 응답은 각 서보가 개별적으로 전송
- ID 변경 시 주의 필요

---

## 관련 문서
- [Serial 프로토콜 (FA AF/FC CF)](Protocol_Serial.md)
- [제어보드 프로토콜 (A9 9A)](Protocol_Control_Board.md)
- [하드웨어 배선 가이드](Hardware_Wiring.md)

---

**문서 버전**: 1.0  
**최종 업데이트**: 2025-11-05  
**적용 대상**: UBTECH 60kg/25kg CAN 버스 서보 (1세대)

⚠️ **면책조항**: 본 문서는 참고용으로만 제공됩니다. 상업적 용도로 사용 금지.
